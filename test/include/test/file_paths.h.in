#pragma once

#include <filesystem>
#include <vector>

#include "utl/erase_if.h"

#include "soro/utls/coroutine/generator.h"

#include "soro/infrastructure/infrastructure_options.h"
#include "soro/timetable/timetable_options.h"

namespace fs = std::filesystem;

namespace soro {

///////////////////////////////////////////////////////////////////////
// Check if you are editing file_paths.h.in instead of file_paths.h //
//////////////////////////////////////////////////////////////////////

auto const BASE_PATH = fs::path("${CMAKE_CURRENT_SOURCE_DIR}") / "resources";

// --- misc files ---
auto const SORO_CSV_PATH = BASE_PATH / "misc/SORO_Betriebsstellen.csv";
auto const SORO_COORD_PATH = BASE_PATH / "misc/btrs_geo.csv";

// --- infrastructure files ---

auto const SMALL_FOLDER = BASE_PATH / "infrastructure/small/";
auto const DE_ISS_FOLDER = BASE_PATH / "infrastructure/de_iss/";

infra::infrastructure_options const SMALL_OPTS = {
    .determine_conflicts_ = true,
    .gps_coord_path_ = SORO_COORD_PATH,
    .infrastructure_path_ = SMALL_FOLDER,
};

infra::infrastructure_options const DE_ISS_OPTS = {
    .determine_conflicts_ = false,
    .gps_coord_path_ = SORO_COORD_PATH,
    .infrastructure_path_ = DE_ISS_FOLDER,
};

inline std::vector<infra::infrastructure_options> get_all_infra_opts() {
  std::vector<infra::infrastructure_options> all_infra_opts = {SMALL_OPTS,
                                                               DE_ISS_OPTS};

  utl::erase_if(all_infra_opts, [](auto&& opts) {
    return !std::filesystem::exists(opts.infrastructure_path_);
  });

  return all_infra_opts;
}

// --- timetable files ---

auto const FOLLOW_FOLDER = BASE_PATH / "timetable/csv/follow/";
auto const FOLLOW_ARCHIVE = FOLLOW_FOLDER / "follow.fpl";

auto const OVERTAKE_FOLDER = BASE_PATH / "timetable/csv/overtake/";
auto const OVERTAKE_ARCHIVE = OVERTAKE_FOLDER / "overtake.fpl";

auto const DE_KSS_FOLDER = BASE_PATH / "timetable/de_kss";

// --- Timetable Options --- //
tt::timetable_options const OVERTAKE_OPTS = {.timetable_path_ =
                                                 OVERTAKE_FOLDER};

tt::timetable_options const FOLLOW_OPTS = {.timetable_path_ = FOLLOW_FOLDER};

tt::timetable_options const DE_KSS_OPTS = {.timetable_path_ = DE_KSS_FOLDER};

const std::vector<tt::timetable_options> ALL_TIMETABLE_OPTIONS = {OVERTAKE_OPTS,
                                                                  FOLLOW_OPTS};

// --- Test Scenarios ---
struct test_scenario {
  infra::infrastructure_options infra_opts_;
  tt::timetable_options timetable_opts_;
};

test_scenario const FOLLOW_SCENARIO{.infra_opts_ = SMALL_OPTS,
                                    .timetable_opts_ = FOLLOW_OPTS};

test_scenario const OVERTAKE_SCENARIO{.infra_opts_ = SMALL_OPTS,
                                      .timetable_opts_ = OVERTAKE_OPTS};

test_scenario const DE_SCENARIO{.infra_opts_ = DE_ISS_OPTS,
                                .timetable_opts_ = DE_KSS_OPTS};

inline std::vector<test_scenario> get_all_test_scenarios() {
  std::vector<test_scenario> scenarios{FOLLOW_SCENARIO, OVERTAKE_SCENARIO,
                                       DE_SCENARIO};

  utl::erase_if(scenarios, [](auto&& scenario) {
    return !std::filesystem::exists(
               scenario.infra_opts_.infrastructure_path_) ||
           !std::filesystem::exists(scenario.timetable_opts_.timetable_path_);
  });

  return scenarios;
}

#define DOCTEST_VALUE_PARAMETERIZED_DATA(data, data_container)            \
  static size_t _doctest_subcase_idx = 0;                                 \
  std::for_each(                                                          \
      data_container.begin(), data_container.end(), [&](const auto& in) { \
        DOCTEST_SUBCASE((std::string(#data_container "[") +               \
                         std::to_string(_doctest_subcase_idx++) + "]")    \
                            .c_str()) {                                   \
          data = in;                                                      \
        }                                                                 \
      });                                                                 \
  _doctest_subcase_idx = 0

}  // namespace soro
